import api from './api';
import {
    cloneData,
    updateInProgress,
    processValidation,
    processCloneSuccess
} from '../../../javascript/actionUtilty';
import {MessageBox} from "../../Common/messagebox";
import React from "react";
import {CLIENT_VALUATION} from "../../Common/constants";

/* ACTIONS */
const UPDATE = 'PROFILE_UPDATE',
      RESET = 'PROFILE_RESET';

/* RESET/UPDATE ACTIONS
*/
export function reset() {
  return (dispatch) => {
    dispatch({type: RESET});
  };
};

export function update(state, props) {
  return (dispatch) => {
    let data = cloneData(state);

    if(props){
      Object.entries(props).forEach(prop => {
        data[prop[0]] = prop[1];
      });
    };
    dispatch({type: UPDATE, data});
  };
};


/* SEARCH */
export function fetchInit(state) {
  return async(dispatch) => {
    let data = cloneData(state);
    data.agreementTable = [];
    dispatch({type: UPDATE, data});
  };
};

export function fetchTable({state, tabledata, step}) {
  return async(dispatch) => {
    let data = cloneData(state);
    tabledata = tabledata.map(x => {
      x.filtered = false
      return x
    })
    data.agreementTable = tabledata
    dispatch({type: UPDATE, data});
  };
};

export function filterTable({state, key, filterVal}) {
  return async(dispatch) => {
    let data = cloneData(state);

    data.agreementTable = data.agreementTable.filter(x => {
      x.filtered = !x[key].toLowerCase().includes(filterVal.toLowerCase())  // exchange profileId for key
      return x
    })

    dispatch({type: UPDATE, data});
  }
}


export function fetchTableEntry({state, query, status, step, lob, profileReadOnly}) {
  return async(dispatch) => {
    let data = cloneData(state);

    data = await updateInProgress(dispatch, data, true, UPDATE);
    const res = await api.fetchTableEntry(query, status, lob);
    data = await updateInProgress(dispatch, data, false, UPDATE);

    if (res.success) {
        data.entryData = res.payload;
        data.entryData.profileReadOnly = profileReadOnly;
        data.entryData.workflowStatus = status;
        data.step = step;
    } else {
        MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
    }

    dispatch({type: UPDATE, data});
  };
};

export function createNewEntry({config, state, step, entryData=null}) {
  return async(dispatch) => {
    let data = cloneData(state);
    data.entryData = entryData
    data.step = step;
    dispatch({type: UPDATE, data});
  };
};


/* SAVE/SUBMIT/CREATE */
export function onSave({state, payload, step, lob}, callBackFn) {
  return async(dispatch) => {
      let data = cloneData(state);
      if(!payload){
          //data =  processValidation(data, "Profile is empty!");
          MessageBox.error('Validation Error', 'Profile is empty!', 500);
      }else {
          data = await updateInProgress(dispatch, data, true, UPDATE);
          const res = await api.onSave(payload, lob);
          data = await updateInProgress(dispatch, data, false, UPDATE);

          if (res.success) {
              data.entryData = CLIENT_VALUATION.toUpperCase() === lob.toUpperCase() ? {cvCompositeProfile : res.payload.profile} : {compositeProfile : res.payload.profile};
              data.step = step;
              callBackFn();
              MessageBox.success('Profile Saved', 'Profile ID : ' + res.payload.id  + ' saved successfully!',500);
          } else {
              let  message = <ul><li>{res.reason.response.data.message}</li></ul>;
              MessageBox.error('Error', message || 'An error has occurred', 500);
          }
      }
    dispatch({type: UPDATE, data});
  };
};

export function onSubmit({state, payload, step, lob}, callBackFn) {
  return async(dispatch) => {
    let data = cloneData(state);
      if(!payload){
          //data =  processValidation(data, "Profile is empty!");
          MessageBox.error('Validation Error', 'Profile is empty!', 500);
      }else {
          // return new item
          data = await updateInProgress(dispatch, data, true, UPDATE);
          const res = await api.onSubmit(payload, lob);
          data = await updateInProgress(dispatch, data, false, UPDATE);

          if (res.success) {
              data.step = step;
              data.entryData = CLIENT_VALUATION.toUpperCase() === lob.toUpperCase() ? {cvCompositeProfile : res.payload.profile} : {compositeProfile : res.payload.profile};
              callBackFn();
              MessageBox.success('Profile Submitted', 'Profile ID : ' + res.payload.id  + ' submitted successfully!',500);
          } else {
              let  message = <ul><li>{res.reason.response.data.message}</li></ul>;
              MessageBox.error('Error', message || 'An error has occurred', 500);
          }
      }
    dispatch({type: UPDATE, data});
  };
};

export function onTerminate({state, payload, step, lob}) {
    return async(dispatch) => {
        let data = cloneData(state);

        // // return new item
        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.onTerminate(lob, payload.legalAgreement.profileId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.step = step;
            data.entryData = {compositeProfile : res.payload.profile};
            MessageBox.success('Termination Requested', 'Profile ID : ' + res.payload.id  + ' terminated successfully!',500);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
        }

        dispatch({type: UPDATE, data});
    };
}

export function onCvTerminate({state, payload, step, lob}) {
    return async(dispatch) => {
        let data = cloneData(state);

        // // return new item
        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.onCvTerminate(lob, payload.cvProfile.profileId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.step = step;
            data.entryData = {cvcompositeProfile : res.payload.profile};
            MessageBox.success('Termination Requested', 'Profile ID : ' + res.payload.id  + ' terminated successfully!',500);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
        }

        dispatch({type: UPDATE, data});
    };
}

export function onActivate({state, payload, step, lob}) {
    return async(dispatch) => {
        let data = cloneData(state);

        // // return new item
        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.onActivate(lob, payload.legalAgreement.profileId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.step = step;
            data.entryData = {compositeProfile : res.payload.profile};
            MessageBox.success('Activation Requested', 'Profile ID : ' + res.payload.id  + ' activated successfully!',500);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
        }

        dispatch({type: UPDATE, data});
    };
}

export function getAllAccounts ({state, lob, profileId}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.getAllAccounts(lob, profileId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.allAccounts = res.payload;
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

export function showAllAccountForNG ({state, lob, legalEntityId, primaryUnifiedDocId}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.showAllAccountForNG(lob, legalEntityId, primaryUnifiedDocId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.ngshowallaccounts = res.payload;
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

export function getAllNettingGroup ({state, lob, primaryUnifiedDocId, legalEntityId}, getNettingData) {
    return async(dispatch) => {
        let data = cloneData(state);
        const res = await api.getAllNettingGroup(lob, primaryUnifiedDocId, legalEntityId);
        if (res.success) {
            getNettingData(res.payload);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
            dispatch({type: UPDATE, data});
        }
    };
};

export function getAllNettingGroupByAgreementId ({state, lob, agreementId}, getNettingData) {
    return async(dispatch) => {
        let data = cloneData(state);
        const res = await api.getAllNettingGroupByAgreementId(lob, agreementId);
        if (res.success) {
            getNettingData(res.payload);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
           // res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
            dispatch({type: UPDATE, data});
        }
    };
};
export function saveNettingGroupProfile({state, payload,  lob, compProfile}) {
    return async(dispatch) => {
        let data = cloneData(state);
        if(!payload){
            data =  processValidation(data, "Profile is empty!");
        }else {
            data = await updateInProgress(dispatch, data, true, UPDATE);
            const res = await api.saveNettingGroupProfile(payload, lob);
            data = await updateInProgress(dispatch, data, false, UPDATE);

            if (res.success) {
                MessageBox.success('Netting Group Saved', 'Netting Group Id : ' + res.payload.profileId  + ' saved successfully!',500);
                //res.status = "Netting Group Saved";
               // processSuccess(data, res);
            } else {
                MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
                //res.reason.response.data.status = res.reason.response.status;
                //data = processError(data, res.reason.response.data);
            }
        }
        dispatch({type: UPDATE, data});
    };
};


export function saveStatementRelationProfile({state, payload,  lob, compProfile}) {
    return async(dispatch) => {
        let data = cloneData(state);
        if(!payload){
            data =  processValidation(data, "Profile is empty!");
        }else {
            data = await updateInProgress(dispatch, data, true, UPDATE);
            const res = await api.saveStatementRelationProfile(payload, lob);
            data = await updateInProgress(dispatch, data, false, UPDATE);

            if (res.success) {
                MessageBox.success('Statement Relation', 'Agreement to Combined Statement relationship saved successfully!', '',500);
            } else {
                MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);

            }
        }
        dispatch({type: UPDATE, data});
    };
};

export function updateNettingGroups({state, payload,  lob, compProfile}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.updateNettingGroups(lob, payload);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.updateNettingGroup = res.payload;
            MessageBox.success('Netting Group Updated', 'Netting Group Id : ' + res.payload.profileId  + ' updated successfully!',500);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
}
export function deleteNettingGroups({state, lob, group}, getNettingData) {
    return async(dispatch) => {
        let data = cloneData(state);
        const res = await api.deleteNettingGroups(lob, group);

        if (res.success) {
            getNettingData();
            MessageBox.success('Netting Group Deleted', 'Netting Group Id : ' + res.payload.profileId  + ' deleted successfully!',500);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
           // res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
            dispatch({type: UPDATE, data});
        }
    };
}
export function getAccountsForGroup ({state, lob, profileId}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.getAccountsForGroup(lob, profileId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.groupAccounts = res.payload;
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

export function getAllCounterpartyGroups ({state, lob, legalEntityId}, getCounterPartyGroupData) {
    return async(dispatch) => {
        let data = cloneData(state);
        const res = await api.getAllCounterpartyGroups(lob, legalEntityId);
        if (res.success) {
            getCounterPartyGroupData(res.payload);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            ///res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
            dispatch({type: UPDATE, data});
        }
    };
};

export function saveCounterpartyGroups({state, lob, group}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.saveCounterpartyGroups(lob, group);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.savedCounterPartyGroup = res.payload;
            MessageBox.success('Counterparty Group', 'Couterpart Group Id : ' + res.payload.profileId  + ' saved successfully!',500);
            //res.status = "Counterparty Group Saved";
           // processSuccess(data, res);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
           // res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
}

export function updateCounterpartyGroups({state, lob, group}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.updateCounterpartyGroups(lob, group);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.updateCounterPartyGroup = res.payload;
            MessageBox.success('Counterparty Group', 'Couterpart Group Id : ' + res.payload.profileId  + ' updated successfully!',500);
            //res.status = "Counterparty Group updated successfully";
            //processSuccess(data, res);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
           // res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
}

export function deleteCounterpartyGroups({state, lob, group}, getCounterPartyGroupData) {
    return async(dispatch) => {
        let data = cloneData(state);
        const res = await api.deleteCounterpartyGroups(lob, group);
        if (res.success) {
            getCounterPartyGroupData();
            MessageBox.success('Counterparty Group', 'Couterpart Group Id : ' + res.payload.profileId  + ' deleted successfully!',500);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
            dispatch({type: UPDATE, data});
        }
    };
}

export function getAccountById ({state, lob, profileId, accountId, module, primaryUnifiedDocId, legalEntityId}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.getAccountById(lob, profileId, accountId, module, primaryUnifiedDocId, legalEntityId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.account = res.payload;
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
           // res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

export function getPreferredAccounts ({state, lob, profileId, status}, handleDetailsRes, isNetting = false) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.getPreferredAccounts(lob, profileId, status);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            if(isNetting){
                data.ngshowallaccounts = res.payload;
            }else{
                data.preferredAccounts = res.payload;
                handleDetailsRes(data.preferredAccounts);
            }
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
           // res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

export function getProfileHistory ({state, lob, profileId, profileType, versionId}, getHistoryData) {
    return async(dispatch) => {
        let data = cloneData(state);
        const res = await api.getProfileHistory(lob, profileId, profileType, versionId);
        if (res.success) {
            data.profileHistory = res.payload;
            getHistoryData(data);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
            dispatch({type: UPDATE, data});
        }
    };
};

export function getAgreementByLeandDocId ({state, lob, legalEntityId, primaryUnifiedDocId, profileId}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.getAgreementByLeandDocId(lob, legalEntityId, primaryUnifiedDocId, profileId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.cloneAgreements = res.data;
        } else {
            data.cloneAgreements = [];
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
           // res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

export function viewAgreementDifferece ({state, lob, sourceId, targetId}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.viewAgreementDifferece(lob, sourceId, targetId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.agreementdiff = res.data || [];
        } else {
            data.agreementdiff = [];
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

export function submitCloning({state, lob, sourceAgreementId, targetAgreementIds}) {
    return async(dispatch) => {
        let data = cloneData(state);

        // // return new item
        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.submitCloning(lob, sourceAgreementId, targetAgreementIds);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            res.status = "Clone Successful.";
            processCloneSuccess(data, res);
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};
export function getAllColtAudits ({state, lob, agreementId, type}) {
    return async(dispatch) => {
        let data = cloneData(state);
        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.getAllColtAudits(lob, agreementId, type);
        data = await updateInProgress(dispatch, data, false, UPDATE);
        if (res.success) {
            data.coltAuditHistory = res.payload;
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
            //data = processError(data, res.reason.response.data);
        }
        dispatch({type: UPDATE, data});
    };
};

export function getColtDetails({state, lob, agreementId}) {
    return async(dispatch) => {
        let data = cloneData(state);

        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.getColtDetails(lob, agreementId);
        data = await updateInProgress(dispatch, data, false, UPDATE);

        if (res.success) {
            data.entryData.coltData = res.payload;
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
            //res.reason.response.data.status = res.reason.response.status;
           // data = processError(data, res.reason.response.data);
        }

        dispatch({type: UPDATE, data});
    };
};

/* SAVE/SUBMIT/CREATE */
export function onColtSave({state, payload, step, lob, event}) {
    return async(dispatch) => {
        let data = cloneData(state);
        if(!payload){
            data =  processValidation(data, "Profile is empty!");
        }else {
            data = await updateInProgress(dispatch, data, true, UPDATE);
            const res = await api.onColtSave(payload, lob, event);
            data = await updateInProgress(dispatch, data, false, UPDATE);

            if (res.success) {
                data.step = step;
                MessageBox.success('Colt Profile', "Colt Profile's "+event+" action performed successfully!",500);
               // res.status = "Colt Profile's "+event+" action performed";
                //processSuccess(data, res);
            } else {
                MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
                //res.reason.response.data.status = res.reason.response.status;
               // data = processError(data, res.reason.response.data);
            }
        }
        dispatch({type: UPDATE, data});
    };
};

export function loadAllStaticData({state, lob, keys}) {
    return async(dispatch) => {
        let data = cloneData(state);
        data = await updateInProgress(dispatch, data, true, UPDATE);
        const res = await api.loadAllStaticData(lob, keys);
        data = await updateInProgress(dispatch, data, false, UPDATE);
        if (res.success) {
            data.staticData = res.payload;
        } else {
            MessageBox.error('Error', res.reason.response.data.message || 'An error has occurred', 500);
        }
        dispatch({type: UPDATE, data});
    };
};


abcd123


import update from 'react-addons-update';
import {FI_REPO, PRINCIPAL_DERIVATIVE, TBA} from "../../Common/constants";

// setup and handle sessionStorage
let ls = sessionStorage.getItem('profile');
ls = ls ? JSON.parse(ls) : null;
const setSessionStorage = (data) => {
  sessionStorage.setItem('profile', JSON.stringify(data));
};

// assign as default values if available
const initialState = ls || {
  agreementTable: null,
  entryData: null,
  coltAuditHistory:[],
  coltData:null,
  allAccounts: null,
  account: null,
  allNettingGroups: null,
  allCounterPartyGroups: null,
  ngshowallaccounts: null,
  spinner: false,
  error: {
    has: false,
    reason: ''
  },
  step: {
    view: 'list', 
    subview: null,
    readonly: false
  }
};

// set defaults
setSessionStorage(initialState);

export function profileReducer(state = initialState, action) {  
  const {type = null, data = initialState} = action;
  const lob =  sessionStorage.getItem('lineofbusiness');

  // console.log(data)

  switch (type) {
    case 'PROFILE_UPDATE':
       if ( [FI_REPO,TBA, PRINCIPAL_DERIVATIVE].indexOf(lob) === -1) {
          setSessionStorage(data);
       }
      return data;   
    case 'PROFILE_RESET':
        if ([FI_REPO,TBA, PRINCIPAL_DERIVATIVE].indexOf(lob) === -1) {
          setSessionStorage(data);
        }
      return update(state, { $set: data });
    default:
      return state;
  }
}

export default profileReducer;
